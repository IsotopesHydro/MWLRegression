contours = list(
showlines = TRUE,   # Ensure lines are visible
start = 0,          # Contour start value
end = 100,          # Contour end value
size = 5,           # Spacing between contour lines (lines every 5 units)
color = 'white',    # Set the line color to white
coloring = 'lines'  # Draw only the lines, not fill
)
) %>%
layout(
title = "Replicated Precipitation Loss Heatmap",
xaxis = list(
title = "Fraction of precipitation lost by fast runoff",
# Ensure labels are ordered from high to low as in the image
categoryorder = "array",
categoryarray = x_labels
),
yaxis = list(
title = "Fraction of remaining water lost by evapotranspiration",
# Ensure labels are ordered from low to high as in the image
categoryorder = "array",
categoryarray = y_labels
)
)
# 3. Define a custom colorscale to match the image (Red -> White -> Blue)
# This is a diverging color scale.
custom_colorscale <- list(
c(0.0, "red"),      # Start (min value) is red
c(0.4, "white"),    # Midpoint (around 40) is white
c(0.6, "white"),    # Maintain white near the center
c(1.0, "blue")     # End (max value) is blue
)
# 4. Create the Heatmap with Contours
fig <- plot_ly(
x = as.numeric(xy$x),
y = as.numeric(xy$y),
z = as.matrix(z),
type = "heatmap",
# Use the custom color scale
colorscale = custom_colorscale,
# Customize the color axis to match the range (0 to 100)
zmin = 0,
zmax = 100,
# Add Contours (the white grid lines in the image)
contours = list(
showlines = TRUE,   # Ensure lines are visible
start = 0,          # Contour start value
end = 100,          # Contour end value
size = 5,           # Spacing between contour lines (lines every 5 units)
color = 'white',    # Set the line color to white
coloring = 'lines'  # Draw only the lines, not fill
)
) %>%
layout(
title = "Replicated Precipitation Loss Heatmap",
xaxis = list(
title = "Fraction of precipitation lost by fast runoff",
# Ensure labels are ordered from high to low as in the image
categoryorder = "array",
categoryarray = as.numeric(xy$x)
),
yaxis = list(
title = "Fraction of remaining water lost by evapotranspiration",
# Ensure labels are ordered from low to high as in the image
categoryorder = "array",
categoryarray = as.numeric(xy$y)
)
)
fig
# Example data
x <- seq(-3, 3, length = 100)
y <- seq(-3, 3, length = 100)
z <- outer(x, y, function(x, y) cos(x^2 + y^2))
# Basic heatmap with contours
filled.contour(
x, y, z,
color.palette = terrain.colors,
plot.title = title(main = "Heatmap with Contours", xlab = "X", ylab = "Y"),
plot.axes = {
axis(1); axis(2)
contour(x, y, z, add = TRUE, col = "black", drawlabels = TRUE)
}
)
library(ggplot2)
# Prepare data
x <- seq(-3, 3, length = 100)
y <- seq(-3, 3, length = 100)
z <- outer(x, y, function(x, y) cos(x^2 + y^2))
df <- expand.grid(x = x, y = y)
df$z <- as.vector(z)
# Heatmap with contour lines
ggplot(df, aes(x, y, z = z)) +
geom_tile(aes(fill = z)) +
geom_contour(color = "black", alpha = 0.8) +
scale_fill_viridis_c() +
labs(title = "Heatmap with Contours", x = "X", y = "Y", fill = "Z") +
theme_minimal()
# Custom color scale definition
custom_colorscale <- list(
c(0.0, "red"),      # Start (min value) is red
c(0.4, "white"),    # Midpoint (around 40%) is white
c(0.6, "white"),    # Maintain white near the center
c(1.0, "blue")      # End (max value) is blue
)
# Convert to color ramp function usable by filled.contour()
color_fun <- colorRampPalette(c("red", "white", "blue"))
xy <- read.table(file = "E:/LAVORO/scriptRStudio/3Dplot/xy.txt", sep = "\t", header = T, dec = ".")
z <- read.table(file = "E:/LAVORO/scriptRStudio/3Dplot/z.txt", sep = "\t", header = T, dec = ".")
z = as.matrix(z)
x = as.numeric(xy$x)
y = as.numeric(xy$y)
z = as.matrix(z)
# Heatmap with contours
filled.contour(
x, y, z,
color.palette = color_fun,
nlevels = 30,  # Number of color levels
plot.title = title(main = "Heatmap with Custom Color Scale + Contours",
xlab = "X", ylab = "Y"),
plot.axes = {
axis(1); axis(2)
contour(x, y, z, add = TRUE, col = "black", lwd = 1)
}
)
xy <- read.table(file = "E:/LAVORO/scriptRStudio/3Dplot/xy.txt", sep = "\t", header = T, dec = ".")
z <- read.table(file = "E:/LAVORO/scriptRStudio/3Dplot/z.txt", sep = "\t", header = T, dec = ".")
# Custom color scale definition
custom_colorscale <- list(
c(0.0, "red"),      # Start (min value) is red
c(0.4, "white"),    # Midpoint (around 40%) is white
c(0.6, "white"),    # Maintain white near the center
c(1.0, "blue")      # End (max value) is blue
)
# Convert to color ramp function usable by filled.contour()
color_fun <- colorRampPalette(c("red", "white", "blue"))
x = as.numeric(xy$x)
y = as.numeric(xy$y)
z = as.matrix(z)
# Heatmap with contours
filled.contour(
x, y, z,
color.palette = color_fun,
nlevels = 30,  # Number of color levels
plot.title = title(main = "Heatmap with Custom Color Scale + Contours",
xlab = "X", ylab = "Y"),
plot.axes = {
axis(1); axis(2)
contour(x, y, z, add = TRUE, col = "black", lwd = 1)
}
)
# Heatmap with contours
filled.contour(
x, y, z,
color.palette = custom_colorscale,
nlevels = 30,  # Number of color levels
plot.title = title(main = "Heatmap with Custom Color Scale + Contours",
xlab = "X", ylab = "Y"),
plot.axes = {
axis(1); axis(2)
contour(x, y, z, add = TRUE, col = "black", lwd = 1)
}
)
?colorRampPalette
# Convert to color ramp function usable by filled.contour()
color_fun <- colorRampPalette(c("red", "white", "blue"),bias = 3)
# Heatmap with contours
filled.contour(
x, y, z,
color.palette = custom_colorscale,
nlevels = 30,  # Number of color levels
plot.title = title(main = "Heatmap with Custom Color Scale + Contours",
xlab = "X", ylab = "Y"),
plot.axes = {
axis(1); axis(2)
contour(x, y, z, add = TRUE, col = "black", lwd = 1)
}
)
# Heatmap with contours
filled.contour(
x, y, z,
color.palette = color_fun,
nlevels = 30,  # Number of color levels
plot.title = title(main = "Heatmap with Custom Color Scale + Contours",
xlab = "X", ylab = "Y"),
plot.axes = {
axis(1); axis(2)
contour(x, y, z, add = TRUE, col = "black", lwd = 1)
}
)
# Heatmap with contours
filled.contour(
x, y, z,
color.palette = color_fun,
nlevels = 30,  # Number of color levels
plot.title = title(main = "Infiltrating precipitation fraction",
xlab = "Fast runoff fraction", ylab = "Evapotraspiration fraction"),
plot.axes = {
axis(1); axis(2)
contour(x, y, z, add = TRUE, col = "black", lwd = 1.6, labcex = 0.8, labcol = "black")
}
)
# Heatmap with contours
filled.contour(
x, y, z,
color.palette = color_fun,
nlevels = 30,  # Number of color levels
plot.title = title(xlab = "Fast runoff fraction", ylab = "Evapotraspiration fraction"),
plot.axes = {
axis(1); axis(2)
contour(x, y, z, add = TRUE, col = "black", lwd = 1.6, labcex = 0.8, labcol = "black")
},
key.title = mtext("Infiltrating precipitation fraction", side = 3, line = 1.5, cex = 1)  # <-- Legend title here
)
# Heatmap with contours
filled.contour(
x, y, z,
color.palette = color_fun,
nlevels = 30,  # Number of color levels
plot.title = title(xlab = "Fast runoff fraction", ylab = "Evapotraspiration fraction"),
plot.axes = {
axis(1); axis(2)
contour(x, y, z, add = TRUE, col = "black", lwd = 1.6, labcex = 0.8, labcol = "black")
}
)
# Heatmap with contours
filled.contour(
x, y, z,
color.palette = color_fun,
nlevels = 30,  # Number of color levels
plot.title = title(xlab = "Fast runoff fraction", ylab = "Evapotraspiration fraction"),
plot.axes = {
axis(1); axis(2)
contour(x, y, z, add = TRUE, col = "black", lwd = 1.6, labcex = 0.8, labcol = "black")
}
)
library(devtools)
devtools::install_github("IsotopesHydro/MWLRegression", upgrade_dependencies = FALSE)
library(devtools)
devtools::install_github("IsotopesHydro/MWLRegression", upgrade_dependencies = FALSE)
library(MWLRegression)
detach("package:MWLRegression", unload = TRUE)
library(MWLRegression)
remove.packages("MWLRegression")
devtools::install_github("IsotopesHydro/MWLRegression")
install.packages("smart")
library(smart)
library(smatr)
library('smatr')
install.packages("smatr")
library(smatr)
TS_gen <- function(n, trend_m, s_max, s_min, noise_m, noise_sd, seasonal_shift) {
# Time vector
time <- 1:n
# Trend component
trend <- trend_m * time
# Seasonal component
season_min <- s_min
season_max <- s_max
amplitude <- (season_max - season_min) / 2
vertical_shift <- (season_max + season_min) / 2
# Phase shift added here (in time units)
seasonality <- amplitude * sin(2 * pi * (time + seasonal_shift) / 12) + vertical_shift
# Noise component
noise <- rnorm(n, mean = noise_m, sd = noise_sd)
# Combine all components
ts_data <- trend + seasonality + noise
return(ts_data)
}
yorkREG <- function(Xi, Yi, errXi, errYi, iter, plot){ ##### Initialize the function to perform LSE York regression
bVect <-c(NA) # Vector to store all estimated slope values
OLS <- summary(lm(Yi~Xi)) # OLS to obtain the starting slope value
bOLS <- as.numeric(OLS$coefficients[2,1])  #starting OLS slope value stored for computation and subsequent plotting
aOLS <- as.numeric(OLS$coefficients[1,1])  #OLS intercept stored for subsequent plotting
bVect[1] <- bOLS # insert the starting OLS slope value in the first position of the Vector to store all estimated slope values
wXi <- 1/(errXi^2) # Xi weights equal to 1 / Xi error
wYi <- 1/(errYi^2) # Yi weights equal to 1 / Yi error
options(warn=-1)
ifelse(is.na(cor(errXi, errYi)), yes = ri <- 10^-20, no = ri <- cor(errXi, errYi)) # estimate correlation between errors in X and Y. If the errors are equal for all Xi and Yi respectively,
#ifelse(is.na(cor(errXi, errYi)), yes = ri <- 10^-20, no = ri <-0.1) # estimate correlation between errors in X and Y. If the errors are equal for all Xi and Yi respectively,
options(warn=0)                                                                                   # then function corr() gives an 'NA' result, in this case the 'ri' is set = 10^-10
alphai <- sqrt(wXi*wYi) # compute parameter alpha
for(i in 1:iter){ # iteration for computing the slope value
Wi <- (wXi*wYi)/(wXi+(bVect[i]^2)*wYi-2*bVect[i]*ri*alphai) # Use the weights, with the value of last computed slope and the correlations ri, and alpha values, to compute Wi for each point
# Use the observed points (Xi ,Y i) and Wi to calculate  ̄X  and  ̄Y , from which Ui and Vi , and hence bi can be evaluated for each point
X <- (sum(Wi*Xi))/(sum(Wi))
Y <- (sum(Wi*Yi))/(sum(Wi))
Ui <- Xi - X
Vi <- Yi - Y
BETAi <- Wi*((Ui/wYi)+((bVect[i]*Vi)/wXi)-(bVect[i]*Ui+Vi)*(ri/alphai))
# Use Wi , Ui , Vi , and bi in the expression for b in Eq. ~13b! to calculate an improved estimate of b
bVect[i+1] <- sum(Wi*BETAi*Vi)/sum(Wi*BETAi*Ui)
}
b <- bVect[length(bVect)] # final slope value
a <- Y - b*X # intercept given the final slope value
xi <- X + BETAi # expectation for the Xi values
yi <- Y + b*BETAi # expectation for the Yi values
x <- (sum(Wi*xi))/(sum(Wi))
y <- (sum(Wi*yi))/(sum(Wi))
ui <- xi - x
vi <- yi - y
Sb2 <- (1/sum(Wi*ui^2)) # error on estimated slope
Sa2 <- (1/sum(Wi))+(x^2)*Sb2 # error on estimated intercept
S <- sum(Wi*(Yi-b*Xi-a)^2) # sum of weighted squared residuals
pX2 <- 1-pchisq(S,length(Xi)-2) # probability
if(plot){ # plotting the Y vs X biplot with OLS and York LSE regression lines
library(ggplot2) #Library for plotting
df <- data.frame(Xi, Yi, errXi, errYi)
reg_lines <- data.frame(
intercept = c(aOLS, a),
slope = c(bOLS, b),
line = c("OLS", "York LSE")
)
p1 <- ggplot(df, aes(x = Xi, y = Yi)) +
geom_point() +
geom_errorbar(aes(ymin = Yi - errYi, ymax = Yi + errYi), width = 0.2, color = "gray", linewidth = 0.8) +
geom_errorbarh(aes(xmin = Xi - errXi, xmax = Xi + errXi), height = 0.2, color = "gray", linewidth = 0.8) +
geom_abline(data = reg_lines, aes(intercept = intercept, slope = slope, color = line), linewidth = 0.5) +
scale_color_manual(values = c("red", "blue")) +
labs(color = "Regression Lines", x = "Xi", y = "Yi")
df3=data.frame(X=rchisq(1:100000, df=length(Xi)-2))
p2 <- ggplot(df3,aes(x=X,y=after_stat(density))) + geom_density(fill='blue') +
geom_vline(aes(xintercept= S), col = "red")
print(p1)
print(p2)
}
res <- list(b,a,xi,yi,Xi-xi,Yi-yi,sqrt(Sb2),sqrt(Sa2),S,pX2,length(Xi)-2, bVect) # results to return
names(res) <- c("York Slope", "York Intercept", "Expected Xi", "Expected Yi", "X-residuals", "Y-residuals", "Slope error", "Intercept error", "SSWR", "X2-probability", "df", "Iterated slope values")
return(res)
}
n <- 24
time <- 1:n
trend_m <- 0
s_max <- -2
s_min <- -15
noise_m <- 0
noise_sd <- 0
seasonal_shift <- -1
# Set seed for reproducibility
set.seed(123)
d18O <- TS_gen(n, trend_m, s_max, s_min, noise_m, noise_sd, seasonal_shift)
d18Oabs <- d18O
iso_m <- 8
iso_q <- 10
d2Habs <- iso_m * d18Oabs + iso_q
sd_18O <- runif(n, min = 0.05, max = 1)
sd_2H <- runif(n, min = 0.5, max = 10)
i=1
err_d18O <- rnorm(n, mean = 0, sd = sd_18O)
err_d2H <- rnorm(n, mean = 0, sd = sd_2H)
d18O <- d18Oabs + err_d18O
d2H <- d2Habs + err_d2H
sma(d2H~d18O)
smalm <- sma(d2H~d18O)
smalm$groupsummary[1,c(5,8)]
as.numeric(smalm$groupsummary[1,c(5,8)])
####### CASE 4
### SYNT DATA
n <- 24
time <- 1:n
trend_m <- 0
s_max <- -2
s_min <- -15
noise_m <- 0
noise_sd <- 0
seasonal_shift <- -1
# Set seed for reproducibility
set.seed(123)
d18O <- TS_gen(n, trend_m, s_max, s_min, noise_m, noise_sd, seasonal_shift)
d18Oabs <- d18O
iso_m <- 8
iso_q <- 10
d2Habs <- iso_m * d18Oabs + iso_q
sd_18O <- runif(n, min = 0.05, max = 1)
sd_2H <- runif(n, min = 0.5, max = 10)
# sd_18O <- 0.1
# sd_2H <- 1
#
# set.seed(42)
# err_d18O <- rnorm(n, mean = 0, sd = sd_18O)
# set.seed(22)
# err_d2H <- rnorm(n, mean = 0, sd = sd_2H)
# err_d18O[c(3,4,5,14,15,16,17,19)] <- rnorm(8, mean = 0, sd = sd_18O*3)
# err_d2H[c(3,4,5,14,15,16,17,19)] <- rnorm(8, mean = 0, sd = sd_2H*3)
testMX <- as.data.frame(matrix(data = NA, nrow = 1000, ncol = 17, ))
colnames(testMX) <- c("bYrok", "aYork", "S", "pX2", "df", "bOLS", "aOLS", "R2both", "MAEall",
"bYrokDumb", "aYorkDumb", "SDumb", "pX2Dumb",
"smab", "smaa",
"mab", "maa")
for(i in 1:1000){
err_d18O <- rnorm(n, mean = 0, sd = sd_18O)
err_d2H <- rnorm(n, mean = 0, sd = sd_2H)
d18O <- d18Oabs + err_d18O
d2H <- d2Habs + err_d2H
testMX[i, c(1:5)] <- unlist(yorkREG(d18O, d2H, sd_18O, sd_2H,
iter = 100, plot = F)[c(1,2,9,10,11)], # here insert regression parameter
use.names = F)
OLS <- lm(d2H ~ d18O)
testMX[i,c(6)] <- as.numeric(summary(OLS)$coefficients[c(2),1])
testMX[i,c(7)] <- as.numeric(summary(OLS)$coefficients[c(1),1])
testMX[i,8] <- summary(OLS)$r.squared
testMX[i,9] <-mean(abs(summary(OLS)$residuals))
testMX[i, c(10:13)] <- unlist(yorkREG(d18O, d2H, rep(0.1,n), rep(1,n),
iter = 100, plot = F)[c(1,2,9,10)], # here insert regression parameter
use.names = F)
smalm <- sma(d2H~d18O)
testMX[i,c(14,15)] as.numeric(smalm$groupsummary[1,c(5,8)])
for(i in 1:1000){
err_d18O <- rnorm(n, mean = 0, sd = sd_18O)
err_d2H <- rnorm(n, mean = 0, sd = sd_2H)
d18O <- d18Oabs + err_d18O
d2H <- d2Habs + err_d2H
testMX[i, c(1:5)] <- unlist(yorkREG(d18O, d2H, sd_18O, sd_2H,
iter = 100, plot = F)[c(1,2,9,10,11)], # here insert regression parameter
use.names = F)
OLS <- lm(d2H ~ d18O)
testMX[i,c(6)] <- as.numeric(summary(OLS)$coefficients[c(2),1])
testMX[i,c(7)] <- as.numeric(summary(OLS)$coefficients[c(1),1])
testMX[i,8] <- summary(OLS)$r.squared
testMX[i,9] <-mean(abs(summary(OLS)$residuals))
testMX[i, c(10:13)] <- unlist(yorkREG(d18O, d2H, rep(0.1,n), rep(1,n),
iter = 100, plot = F)[c(1,2,9,10)], # here insert regression parameter
use.names = F)
smalm <- sma(d2H~d18O)
testMX[i,c(14,15)] <- as.numeric(smalm$groupsummary[1,c(5,8)])
malm <-  sma(d2H~d18O, method = c("MA"))
testMX[i,c(16,17)] <- as.numeric(malm$groupsummary[1,c(5,8)])
}
write.table(testMX, file = "G:/Il mio Drive/MWLs_EMS_&_Paper/Script/OUT_Synt_24/OUTsynt_case4_plusSMAMA.txt")
####### CASE 4
### SYNT DATA
n <- 24
time <- 1:n
trend_m <- 0
s_max <- -2
s_min <- -15
noise_m <- 0
noise_sd <- 0
seasonal_shift <- -1
# Set seed for reproducibility
set.seed(123)
d18O <- TS_gen(n, trend_m, s_max, s_min, noise_m, noise_sd, seasonal_shift)
d18Oabs <- d18O
iso_m <- 8
iso_q <- 10
d2Habs <- iso_m * d18Oabs + iso_q
sd_18O <- runif(n, min = 0.05, max = 1)
sd_2H <- runif(n, min = 0.5, max = 10)
# sd_18O <- 0.1
# sd_2H <- 1
#
# set.seed(42)
# err_d18O <- rnorm(n, mean = 0, sd = sd_18O)
# set.seed(22)
# err_d2H <- rnorm(n, mean = 0, sd = sd_2H)
# err_d18O[c(3,4,5,14,15,16,17,19)] <- rnorm(8, mean = 0, sd = sd_18O*3)
# err_d2H[c(3,4,5,14,15,16,17,19)] <- rnorm(8, mean = 0, sd = sd_2H*3)
testMX <- as.data.frame(matrix(data = NA, nrow = 1000, ncol = 17, ))
colnames(testMX) <- c("bYrok", "aYork", "S", "pX2", "df", "bOLS", "aOLS", "R2both", "MAEall",
"bYrokDumb", "aYorkDumb", "SDumb", "pX2Dumb",
"smab", "smaa",
"mab", "maa")
set.seed(NULL)
for(i in 1:1000){
sd_18O <- runif(n, min = 0.05, max = 1)
sd_2H <- runif(n, min = 0.5, max = 10)
err_d18O <- rnorm(n, mean = 0, sd = sd_18O)
err_d2H <- rnorm(n, mean = 0, sd = sd_2H)
d18O <- d18Oabs + err_d18O
d2H <- d2Habs + err_d2H
testMX[i, c(1:5)] <- unlist(yorkREG(d18O, d2H, sd_18O, sd_2H,
iter = 100, plot = F)[c(1,2,9,10,11)], # here insert regression parameter
use.names = F)
OLS <- lm(d2H ~ d18O)
testMX[i,c(6)] <- as.numeric(summary(OLS)$coefficients[c(2),1])
testMX[i,c(7)] <- as.numeric(summary(OLS)$coefficients[c(1),1])
testMX[i,8] <- summary(OLS)$r.squared
testMX[i,9] <-mean(abs(summary(OLS)$residuals))
testMX[i, c(10:13)] <- unlist(yorkREG(d18O, d2H, rep(0.1,n), rep(1,n),
iter = 100, plot = F)[c(1,2,9,10)], # here insert regression parameter
use.names = F)
smalm <- sma(d2H~d18O)
testMX[i,c(14,15)] <- as.numeric(smalm$groupsummary[1,c(5,8)])
malm <-  sma(d2H~d18O, method = c("MA"))
testMX[i,c(16,17)] <- as.numeric(malm$groupsummary[1,c(5,8)])
}
write.table(testMX, file = "G:/Il mio Drive/MWLs_EMS_&_Paper/Script/OUT_Synt_24/OUTsynt_case4_plusSMAMA_sdVAR.txt")
smalm$r2
smalm$coef
smalm$n
smalm$pval
smatr::residuals(smalm)
residuals(smalm)
library(devtools)
library(roxygen2)
getwd()
devtools::document()
devtools::document()
setwd("G:/Il mio Drive/MWLs_EMS_&_Paper/Script/ForPublication/MWLRegression/")
devtools::document()
warnings()
devtools::document()
setwd("G:/Il mio Drive/MWLs_EMS_&_Paper/Script/ForPublication/MWLRegression/")
devtools::document()
library(devtools)
library(MWLRegression)
remove.packages("MWLRegression")
devtools::install_github(" IsotopesHydro/MWLRegression")
devtools::install_github("IsotopesHydro/MWLRegression")
detach(MWLRegression)
detach(MWLRegression)
detach('MWLRegression')
detach("MWLRegression")
