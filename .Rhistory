# Numero di punti sperimentali
N <- 120
# Valori medi delle N ascisse (delta O)
X0 <- 6.5*sin(2*pi*(1:N)/12)-8.5
# Valori medi delle corrisoindenti ordinate (delta H)
Y0 <- 8*X0+10
#Deviazione standard sulle misure in ascissa
sX0 <- 0.1
#Deviazione standard sulle misure in ordinata
sY0 <- 1
#Calcolo dei coefficienti dell'equazione (di secondo grado in b) b^2+B*b+C=0
B <- ((-N*sum(Y^2)+(sum(Y))^2)*(sX0)^2-(-N*sum(X^2)+(sum(X))^2)*(sY0)^2)/((N*sum(X*Y)-sum(X)*sum(Y))*(sX0)^2)
#generazione del k-esimo esperimento
X <- X0+rnorm(N, mean = 0, sd = sX0)
Y <- Y0+rnorm(N, mean = 0, sd = sY0)
#Calcolo dei coefficienti dell'equazione (di secondo grado in b) b^2+B*b+C=0
B <- ((-N*sum(Y^2)+(sum(Y))^2)*(sX0)^2-(-N*sum(X^2)+(sum(X))^2)*(sY0)^2)/((N*sum(X*Y)-sum(X)*sum(Y))*(sX0)^2)
C <- -(sY0/sX0)^2
#risoluzione dell'equazione di secondo grado per determinare il b "empirico"
delta=B^2-4*C;
b0 <- c(b0,(-B+sqrt(delta))/2) #si deve prendere la soluzione col +
b0 <- (-B+sqrt(delta))/2 #si deve prendere la soluzione col +
#Calcolo dei coefficienti dell'equazione (di secondo grado in b) b^2+B*b+C=0
B <- ((-N*sum(Y^2)+(sum(Y))^2)*(sX0)^2-(-N*sum(X^2)+(sum(X))^2)*(sY0)^2)/((N*sum(X*Y)-sum(X)*sum(Y))*(sX0)^2)
C <- -(sY0/sX0)^2
#risoluzione dell'equazione di secondo grado per determinare il b "empirico"
delta=B^2-4*C;
b0 <- (-B+sqrt(delta))/2 #si deve prendere la soluzione col +
#una volta trovato b, il gioco è fatto...
a0 <- (sum(Y)-b0[k]*sum(X))/N
X <- X0+rnorm(N, mean = 0, sd = sX0)
Y <- Y0+rnorm(N, mean = 0, sd = sY0)
#Calcolo dei coefficienti dell'equazione (di secondo grado in b) b^2+B*b+C=0
B <- ((-N*sum(Y^2)+(sum(Y))^2)*(sX0)^2-(-N*sum(X^2)+(sum(X))^2)*(sY0)^2)/((N*sum(X*Y)-sum(X)*sum(Y))*(sX0)^2)
C <- -(sY0/sX0)^2
#risoluzione dell'equazione di secondo grado per determinare il b "empirico"
delta=B^2-4*C;
b0 <- (-B+sqrt(delta))/2 #si deve prendere la soluzione col +
#una volta trovato b, il gioco è fatto...
a0 <- (sum(Y)-b0*sum(X))/N
W0 <- 1/(sY0^2+(b0)^2*sX0^2)
SS0 <- W0*sum((Y-(a0+b0*X))^2)
pX2 <- 1-pchisq(SS0,N-2)
York_Lin_Reg <- function(Xi, Yi, errXi, errYi, iter = 100, plot = T){ ##### Initialize the function to perform LSE York regression
bVect <-c(NA) # Vector to store all estimated slope values
OLS <- summary(lm(Yi~Xi)) # OLS to obtain the starting slope value
bOLS <- as.numeric(OLS$coefficients[2,1])  #starting OLS slope value stored for computation and subsequent plotting
aOLS <- as.numeric(OLS$coefficients[1,1])  #OLS intercept stored for subsequent plotting
bVect[1] <- bOLS # insert the starting OLS slope value in the first position of the Vector to store all estimated slope values
wXi <- 1/(errXi^2) # Xi weights equal to 1 / Xi error
wYi <- 1/(errYi^2) # Yi weights equal to 1 / Yi error
options(warn=-1)
ifelse(is.na(cor(errXi, errYi)), yes = ri <- 10^-20, no = ri <- cor(errXi, errYi)) # estimate correlation between errors in X and Y. If the errors are equal for all Xi and Yi respectively,
options(warn=0)                                                                    # then function corr() gives an 'NA' result, in this case the 'ri' is set = 10^-20
alphai <- sqrt(wXi*wYi) # compute parameter alpha
for(i in 1:iter){ # iteration for computing the slope value
Wi <- (wXi*wYi)/(wXi+(bVect[i]^2)*wYi-2*bVect[i]*ri*alphai) # Use the weights, with the value of last computed slope and the correlations ri, and alpha values, to compute Wi for each point
# Use the observed points (Xi ,Y i) and Wi to calculate  ̄X  and  ̄Y , from which Ui and Vi , and hence bi can be evaluated for each point
X <- (sum(Wi*Xi))/(sum(Wi))
Y <- (sum(Wi*Yi))/(sum(Wi))
Ui <- Xi - X
Vi <- Yi - Y
BETAi <- Wi*((Ui/wYi)+((bVect[i]*Vi)/wXi)-(bVect[i]*Ui+Vi)*(ri/alphai))
# Use Wi , Ui , Vi , and bi in the expression for b in Eq. ~13b! to calculate an improved estimate of b
bVect[i+1] <- sum(Wi*BETAi*Vi)/sum(Wi*BETAi*Ui)
}
b <- bVect[length(bVect)] # final slope value
a <- Y - b*X # intercept given the final slope value
xi <- X + BETAi # expectation for the Xi values
yi <- Y + b*BETAi # expectation for the Yi values
x <- (sum(Wi*xi))/(sum(Wi))
y <- (sum(Wi*yi))/(sum(Wi))
ui <- xi - x
vi <- yi - y
Sb2 <- (1/sum(Wi*ui^2)) # error on estimated slope
Sa2 <- (1/sum(Wi))+(x^2)*Sb2 # error on estimated intercept
S <- sum(Wi*(Yi-b*Xi-a)^2) # sum of weighted squared residuals
Q <- 1-pchisq(S,length(Xi)-2) # probability
if(plot){ # plotting the Y vs X biplot with OLS and York LSE regression lines
library(ggplot2) #Library for plotting
df <- data.frame(Xi, Yi, errXi, errYi)
reg_lines <- data.frame(
intercept = c(aOLS, a),
slope = c(bOLS, b),
line = c("OLS", "York LSE")
)
p1 <- ggplot(df, aes(x = Xi, y = Yi)) +
geom_point() +
geom_errorbar(aes(ymin = Yi - errYi, ymax = Yi + errYi), width = 0.2, color = "gray", linewidth = 0.8) +
geom_errorbarh(aes(xmin = Xi - errXi, xmax = Xi + errXi), width = 0.2, color = "gray", linewidth = 0.8) +
geom_abline(data = reg_lines, aes(intercept = intercept, slope = slope, color = line), linewidth = 0.5) +
scale_color_manual(values = c("red", "blue")) +
labs(color = "Regression Lines", x = "Xi", y = "Yi")
df3=data.frame(X=rchisq(1:100000, df=length(Xi)-2))
p2 <- ggplot(df3,aes(x=X,y=after_stat(density))) + geom_density(fill='blue') +
geom_vline(aes(xintercept= S), col = "red")
dfbreps <- data.frame(Iterations = c(1:length(bVect)), bValues = bVect)
p3 <- ggplot(dfbreps, aes(x = Iterations, y = bValues)) +
geom_point() +
geom_line() +
labs(
x = "Iterations",
y = "Iterated b values")
print(p3)
print(p1)
print(p2)
}
res <- list(b,a,xi,yi,Xi-xi,Yi-yi,sqrt(Sb2),sqrt(Sa2),S,Q,length(Xi)-2, bVect) # results to return
names(res) <- c("York Slope", "York Intercept", "Expected Xi", "Expected Yi", "X-residuals", "Y-residuals", "Slope uncertainty", "Intercept uncertainty", "S", "Q", "df", "Iterated slope values")
return(res)
}
errXi <- rep(sX0, 120)
errYi <- rep(sY0, 120)
York_Lin_Reg(X, Y, errXi, errYi, iter = 100, plot = T)
t <- rep(1,10)
t[1] == t[c(2:10)]
t[1] == t[c(1:10)]
sum(t[1] == t[c(1:10)])
sum(t[1] != t[c(1:10)])
t[3]=1.0000001
sum(t[1] != t[c(1:10)])
devtools -v
install.packages("devtools")
install.packages("roxygen2")
install.packages("Rtools")
library(devtools)
library(roxygen2)
getwd()
devtools::create("MWL_Regression")
devtools::create("MWLRegression")
devtools::document()
rlang::last_trace()
rlang::last_trace("G:/Il mio Drive/MWLs_EMS_&_Paper/Script/ForPublication/MWLRegression")
getwd
getwd()
setwd("G:/Il mio Drive/MWLs_EMS_&_Paper/Script/ForPublication/MWLRegression")
devtools::document()
warnings()
getwd()
devtools::document()
t
t[3] =2
t
e = rep(2,10)
sum(e[1]!=e[c(2:10)])
sum(e[1]!=e[c(2:10)],t[1]!=t[c(2:10)])
if(1==2)
cs
if(1==2){print(2)}
if(1=2){print(2)}
warnsigmaEqualityCheck <- character()
warnsigmaEqualityCheck
warnsigmaEqualityCheck <- str()
devtools::document()
devtools::document()
devtools::install_github("IsotopesHydro/MWLRegression", upgrade_dependencies = FALSE)
devtools::install_github("IsotopesHydro/MWLRegression", upgrade_dependencies = FALSE)
gc()
